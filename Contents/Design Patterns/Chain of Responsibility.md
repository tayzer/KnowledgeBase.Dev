## Intent
The Chain of Responsibility pattern avoids coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request. The request gets passed along a chain of handlers until one of them handles the request.
## Also Known As
CoR, Chain of Command
## Problem
In a complex system, various objects handle different types of requests. Hard-wiring the request processing to specific handlers or using conditionals to make decisions about which handler to use can lead to inflexible, hard to maintain code.
## Solution
Create a chain of objects (handlers) that can handle a request, with each handler in the chain holding a reference to the next handler. The request travels along the chain until a handler handles it. This allows an object to send a request without knowing which object will handle it.
## Applicability or When to Use
- More than one object may handle a request, and the handler isn't known a priori. The handler should be ascertained automatically.
- You want to issue a request to one of several objects without specifying the receiver explicitly.
- The set of objects that can handle a request should be specified dynamically.
## Structure
![Diagram](link-to-your-chain-of-responsibility-diagram)

The structure involves a `Handler` interface, a series of `ConcreteHandler` classes, and client interaction.
## Participants
- **Handler**: Defines an interface for handling the requests and (optionally) implements the successor link.
- **ConcreteHandler**: Handles requests it is responsible for; if it can handle the request, it does so, otherwise, it forwards the request to its successor.
- **Client**: Initiates the request to a `ConcreteHandler` object on the chain.
## Collaborations
- When a client issues a request, the request propagates along the chain until a `ConcreteHandler` object takes responsibility for handling it.
## Consequences
- Reduced coupling: The pattern frees an object from knowing which other object handles a request.
- Added flexibility in assigning responsibilities to objects: Handlers can be changed or new ones added into the system dynamically.
- Receipt isn't guaranteed: Since a request has no explicit receiver, there's no guarantee it'll be handledâ€”the request can reach the end of the chain and not be handled at all.
## Known Uses
- GUI frameworks use it to handle events. The event can be generated by any element (like a button), and different elements can handle the event differently.
- Job schedulers where the task gets passed through various stages of processing before it's completed.
## Related Patterns
- **Command**: Chain of Responsibility can use Command objects to represent requests.
- **Composite**: A handler in Chain of Responsibility can be a Composite. There, a request can be forwarded along a complex object structure.
- **Decorator**: These patterns are similar in that they recursively pass requests through a chain of objects, but Decorator adds responsibilities, not just handles requests.
